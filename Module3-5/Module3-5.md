* **다음 지시를 그대로 구현하라. 너는 표준 라이브러리만 쓰는 Python 3.11 시니어 엔지니어다. `module_3_5` 패키지를 생성하고, 오직 3-2가 산출한 NormClause JSON(필드 예: `id, index_path, text, normalized_text, title, tags, category, subcategory, canonical_terms`)과 3-4가 산출한 hits JSON(필드 예: `rule_id, clause_id, match_type{lex|syntax|table|num}, spans[(start,end)], strength, notes`)만을 입력으로 받아 증거 스니펫(evidence) JSON을 생산하라. 3-5는 문서 구조를 새로 파싱하지 않고(3-1 침범 금지), 용어 정규화/온톨로지를 재구축하지 않으며(3-2 침범 금지), 규칙 의미를 재해석하지 않는다(3-3/3-4 침범 금지). 각 히트에 대해 해당 `clause_id`의 원문 `text`(필수)와 보조 `normalized_text`(선택)를 사용해 문장 경계 탐색 → 하이라이트 스팬 병합 → 컨텍스트 확장을 수행하여 길이 120–300자의 결정론적 스니펫을 만든다. 문장 경계는 입력에 문장 경계 정보가 있을 경우 그것을 우선 사용하고(필드명 `sent_boundaries`가 존재하면 신뢰), 없으면 간단한 휴리스틱으로 분할한다(마침표/물음표/느낌표/줄바꿈/‘…’/‘다.’ 패턴과 연속 개행을 경계로 삼되 줄바꿈 두 개 이상은 단락 경계로 처리). 하이라이트 스팬은 `hits.spans`(절대 오프셋이 아니라 조항 내 상대 오프셋으로 가정) 기반으로 겹치는 범위를 병합하고, 스니펫은 가장 스코어가 높은 하이라이트가 포함된 문장을 중심으로 ±1문장을 기본 컨텍스트로 확장하되 목표 길이(120–300자)를 만족하지 않으면 인접 문장 추가 또는 문자 단위 윈도 확장을 통해 충족한다(단어 중간 절단 금지). 표/수치 매치의 경우 `match_type ∈ {table,num}`이면 표 셀 또는 수치가 포함된 문장·셀을 우선 증거로 삼고, 스니펫에는 해당 셀 텍스트와 좌/상단 헤더 라벨을 함께 표현할 수 있도록 표 컨텍스트 구조를 생성한다(텍스트 기반 파싱으로 헤더-값 페어를 복원하고, 가능하면 행/열 인덱스도 함께 기록). 출력 스키마는 `Evidence{ rule_id, clause_id, match_type, snippet, snippet_char_start_abs, snippet_char_end_abs, highlights_rel:[[s,e],...], sentence_span:[sent_start_index,sent_end_index], context_window_sentences:1, overflow:bool, table_ctx?:{cell_text, row, col, header_top, header_left}, numeric_ctx?:{value, unit, comparator, rhs_display}, strength }`로 고정하고, `snippet_char_start_abs/…end_abs`는 문서 전체가 아닌 해당 조항 원문 기준의 절대 오프셋으로 계산한다(3-1이 제공한 조항 `start` 오프셋을 받지 못하므로, 본 모듈은 조항 내 기준 절대좌표만 관리한다). 선택 플래그로 `--redact-sensitive`를 지원하여 계좌번호·주민번호·전화번호·이메일 등 민감 패턴을 비가역 마스킹(`****`)하고 마스킹 여부를 `notes`에 남긴다(기본 False). 패키지 구조는 `module_3_5/extractor.py`(핵심 로직), `module_3_5/schemas.py`(데이터 모델), `module_3_5/cli.py`(입력/출력 JSON 파이프), `tests/test_extractor.py`(pytest), `samples/clauses.json` 및 `samples/hits.json`으로 구성하며, CLI는 `python -m module_3_5.cli --clauses norm_clauses.json --hits hits.json --out evidence.json --target-min 120 --target-max 300 --redact-sensitive false` 형식을 제공한다. 알고리즘은 (1) `hits`를 `clause_id`로 그룹화, (2) 각 조항 `text`에서 문장 경계 인덱스 배열을 계산 또는 재사용, (3) 하이라이트 스팬을 문장 인덱스에 사상, (4) 가장 밀도가 높은 문장 블록을 중심으로 ±1문장 컨텍스트 선택, (5) 목표 길이에 맞춰 안전하게 잘라내고 상대 하이라이트 좌표를 재계산, (6) `match_type`이 표/수치인 경우 표 라벨/수치 표시를 결합하여 `table_ctx`/`numeric_ctx`를 채우는 순서로 진행한다. 모든 연산은 UTF-8 문자 단위 인덱싱으로 수행하며, 멀티바이트 문자에서도 인덱스가 어긋나지 않도록 Python의 유니코드 코드포인트 기준으로 계산한다. 테스트·수락 기준은 샘플에서 ① 한 히트당 스니펫 길이가 120–300자 범위, ② 중첩 하이라이트가 올바르게 병합되어 겹치지 않는 상대 좌표로 산출, ③ `±1문장` 컨텍스트 규칙이 일관되게 적용, ④ `table/num` 히트에서 표/수치 컨텍스트가 채워짐, ⑤ `--redact-sensitive` 사용 시 민감 정보가 마스킹되고 하이라이트 좌표가 여전히 일치하는 것이다. 외부 패키지는 사용하지 말고, 정규식은 미리 컴파일하며, 어떤 단계에서도 3-1/3-2/3-4의 역할을 재수행하지 말라.**

