* **\*\*3-3 규칙 런타임 로더(컴파일·버전·플래그)\*\*는 “룰=데이터, 엔진=코드” 원칙을 지키면서, 3-1/3-2의 출력만을 참조하고 그 역할을 침범하지 않도록 설계한다. 이 모듈의 목적은 (1) DSL/JSON 규칙팩을 로드해 정합성·버전·중복/충돌을 검증하고, (2) 실행엔진(3-4)이 즉시 사용할 수 있는 ruleset\_runtime 형태로 컴파일하며, (3) 실험 플래그/AB/캔어리를 반영해 배포 단위를 제어하는 것이다. 3-3은 텍스트를 직접 스캔하지 않고, 3-1의 분절/메타태그(`header/annex_ref/...`)와 3-2의 정규화 산출물(`category/subcategory/canonical_terms/normalized_text/def_bindings`)만을 조건의 좌표계로 사용한다. 즉, 3-3은 “룰 정의→검증→컴파일→배포제어”만 담당하고, 매칭·스코어링은 3-4/3-6의 책임으로 남긴다.**  
* **입력은 (a) 규칙팩 파일(권장: JSON, 선택: 경량 DSL), (b) 엔진 호환정보(예: `engine_semver`), (c) 실험설정(플래그/트래픽 분배/활성화 기간)이다. 출력은 ruleset\_runtime.json으로, 메타(룰셋 id, semver, 작성자, 생성시각, sha256), 호환성(필수 `engine_semver` 범위), 인덱스(카테고리/태그/키워드 기반 역색인), 컴파일된 패턴(정규식 토큰·키워드 세트·부정패턴·증거 힌트), 우선순위/중재정책, 활성화 규칙(비율·대상·기간), 그리고 요구 피처 선언(예: `requires = ["numeric_amount","date_range"]` → 3-4C 실행 힌트)을 포함한다. 스키마 기준으로 각 규칙은 `rule_id(고유)`, `version(semver)`, `scope(예: category=="MONEY.DEPOSIT")`, `matchers(키워드/정규식/부정/근접)`, `severity(OK/WARN/HIGH)`, `weight(0..1)`, `priority(정수)`, `evidence_hints(추출 키워드)`, `requires(파이프라인 요구사항)`, `flags(실험 태그)`, `activation(퍼센트 롤아웃·테넌트/문서 해시 타깃팅·시작/종료일)`를 가진다. 3-2와 충돌하지 않도록 `scope`와 `matchers`는 항상 3-2의 정규화 뷰 필드명만 참조한다(예: `category`, `canonical_terms`, `normalized_text`, 3-1 태그는 보정용 보조조건으로만 사용).**  
* **검증 단계는 결정론적 파이프라인으로 구성한다. 스키마 검증(필수 필드·타입·허용 enum) → 아이디 유일성(중복 `rule_id` 금지) → 우선순위 체계 검증(동일 scope에서 동일 severity/priority 충돌 시 경고 또는 금칙 정책) → 정규식 안전성(금지 패턴·백트래킹 폭탄 차단, 길이 상한) → 호환성 체크(룰셋 `engine_semver` 범위와 현재 엔진 버전 교집합 확인) → 실험설정 유효성(퍼센트 합계, 타깃 필터 구문) → 참조 일관성(정의되지 않은 카테고리/서브카테고리, 미지원 `requires` 값 탐지). 충돌 감지는 (1) 서로 상반된 severity가 동일 조건집합을 겨냥하는 경우, (2) 상위/하위 스코프가 완전히 중첩되며 낮은 priority가 높은 priority를 항상 가리는 경우(그림자 규칙)까지 포함한다. 기본 정책은 “금칙\>경고\>권고” 계층을 전역으로 고정하고, 완전 중첩 시 더 구체적 스코프가 승리하며, 동급이면 더 높은 `priority`가 승리한다. 이 결정 규칙은 컴파일 결과에 중재 테이블로 내보낸다.**  
* **컴파일 단계는 실행 엔진 친화적으로 구조화한다. 카테고리별/태그별 룰 인덱스를 생성해 3-4가 빠르게 후보군을 좁힐 수 있게 하고, 키워드 매칭은 고정 세트로, 정규식은 사전컴파일 객체로 변환한다(패턴 플래그 포함). 부정패턴·근접조건은 파라미터화해 3-4가 조합평가만 하도록 경량화한다. 실험 플래그는 `variant{A,B,...}`와 `allocation{A:50,B:50}` 식으로 정규화하여, 문서 id/테넌트 id 해시 기반 분배 함수를 함께 내보낸다(동일 입력→동일 배정 보장). ruleset\_runtime에는 요구 피처 집계(`"feature_requirements":["numeric_amount","table_cells"]`)도 담아 3-4가 필요한 서브파이프라인만 조건부 활성화하도록 한다.**  
* **CLI는 `python -m module_3_3.cli --rules rules/lease_rules.json --engine 1.0.0 --flags env/ab_flags.json --out build/ruleset_runtime.json` 형태로 제공하고, 표준입출력 파이프를 허용한다. 테스트/수락 기준은 (a) 중복 `rule_id`·그림자 규칙·호환성 불일치 시 빌드 실패, (b) 실험 배정이 동일 입력에서 결정론적으로 고정, (c) 임대차 온톨로지에 없는 범주·필드 참조 시 실패, (d) 컴파일 산출의 인덱스/중재 테이블이 스냅샷 테스트와 일치하는 것이다. 성능 가드레일은 1천 개 룰/200KB 문서 기준 컴파일 \<1초, 메모리 \<200MB. 보안/안정성 측면에서 정규식 길이·연산자 제한과 타임아웃(컴파일 시)을 두고, 외부 코드 주입 형태의 DSL 기능은 금지한다. 운영 관점으로는 룰셋 파일에 `sha256`과 선택적 `signature`를 기록하여 변경 추적/신뢰성을 확보하고, `semver`에 따라 \*\*호환 범위(min/max)\*\*와 브레이킹 변경 보고서를 생성한다. 이 모든 산출물은 3-9 텔레메트리에서 릴리즈 게이트(골든셋 통과율)와 연결될 수 있도록 메타필드를 표준화한다.**  
* 

